package pg_query

import (
	"testing"
	"regexp"
)

func Test_ParseMany(t *testing.T) {
	testData := []struct {
		sql string
	}{
		{``},
		{`VALUES ("")`},

		{`BEGIN TRANSACTION`},
		{`BEGIN TRANSACTION READ ONLY`},
		{`BEGIN TRANSACTION READ WRITE`},
		{`BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE`},
		{`BEGIN TRANSACTION PRIORITY LOW`},
		{`BEGIN TRANSACTION PRIORITY NORMAL`},
		{`BEGIN TRANSACTION PRIORITY HIGH`},
		{`BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE, PRIORITY HIGH`},
		{`BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE, PRIORITY HIGH, READ WRITE`},
		{`COMMIT TRANSACTION`},
		{`ROLLBACK TRANSACTION`},
		{"SAVEPOINT foo"},

		{`CREATE DATABASE a`},
		{`CREATE DATABASE a TEMPLATE = 'template0'`},
		{`CREATE DATABASE a TEMPLATE = 'invalid'`},
		{`CREATE DATABASE a ENCODING = 'UTF8'`},
		{`CREATE DATABASE a ENCODING = 'INVALID'`},
		{`CREATE DATABASE a LC_COLLATE = 'C.UTF-8'`},
		{`CREATE DATABASE a LC_COLLATE = 'INVALID'`},
		{`CREATE DATABASE a LC_CTYPE = 'C.UTF-8'`},
		{`CREATE DATABASE a LC_CTYPE = 'INVALID'`},
		{`CREATE DATABASE a TEMPLATE = 'template0' ENCODING = 'UTF8' LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'INVALID'`},
		{`CREATE DATABASE IF NOT EXISTS a`},
		{`CREATE DATABASE IF NOT EXISTS a TEMPLATE = 'template0'`},
		{`CREATE DATABASE IF NOT EXISTS a TEMPLATE = 'invalid'`},
		{`CREATE DATABASE IF NOT EXISTS a ENCODING = 'UTF8'`},
		{`CREATE DATABASE IF NOT EXISTS a ENCODING = 'INVALID'`},
		{`CREATE DATABASE IF NOT EXISTS a LC_COLLATE = 'C.UTF-8'`},
		{`CREATE DATABASE IF NOT EXISTS a LC_COLLATE = 'INVALID'`},
		{`CREATE DATABASE IF NOT EXISTS a LC_CTYPE = 'C.UTF-8'`},
		{`CREATE DATABASE IF NOT EXISTS a LC_CTYPE = 'INVALID'`},
		{`CREATE DATABASE IF NOT EXISTS a TEMPLATE = 'template0' ENCODING = 'UTF8' LC_COLLATE = 'C.UTF-8' LC_CTYPE = 'INVALID'`},

		{`CREATE INDEX a ON b (c)`},
		{`CREATE INDEX a ON b.c (d)`},
		{`CREATE INDEX ON a (b)`},
		{`CREATE INDEX ON a (b) STORING (c)`},
		{`CREATE INDEX ON a (b) INTERLEAVE IN PARENT c (d)`},
		{`CREATE INDEX ON a (b) INTERLEAVE IN PARENT c.d (e)`},
		{`CREATE INDEX ON a (b ASC, c DESC)`},
		{`CREATE UNIQUE INDEX a ON b (c)`},
		{`CREATE UNIQUE INDEX a ON b (c) STORING (d)`},
		{`CREATE UNIQUE INDEX a ON b (c) INTERLEAVE IN PARENT d (e, f)`},
		{`CREATE UNIQUE INDEX a ON b (c) INTERLEAVE IN PARENT d.e (f, g)`},
		{`CREATE UNIQUE INDEX a ON b.c (d)`},
		{`CREATE INVERTED INDEX a ON b (c)`},
		{`CREATE INVERTED INDEX a ON b.c (d)`},

		{`CREATE TABLE a ()`},
		{`CREATE TABLE a (b INT)`},
		{`CREATE TABLE a (b INT, c INT)`},
		{`CREATE TABLE a (b CHAR)`},
		{`CREATE TABLE a (b CHAR(3))`},
		{`CREATE TABLE a (b VARCHAR)`},
		{`CREATE TABLE a (b VARCHAR(3))`},
		{`CREATE TABLE a (b STRING)`},
		{`CREATE TABLE a (b STRING(3))`},
		{`CREATE TABLE a (b FLOAT)`},
		{`CREATE TABLE a (b SERIAL)`},
		{`CREATE TABLE a (b SMALLSERIAL)`},
		{`CREATE TABLE a (b BIGSERIAL)`},
		{`CREATE TABLE a (b TIME)`},
		{`CREATE TABLE a (b TIME WITH TIME ZONE)`},
		{`CREATE TABLE a (b UUID)`},
		{`CREATE TABLE a (b INET)`},
		{`CREATE TABLE a (b INT NULL)`},
		{`CREATE TABLE a (b INT CONSTRAINT maybe NULL)`},
		{`CREATE TABLE a (b INT NOT NULL)`},
		{`CREATE TABLE a (b INT CONSTRAINT always NOT NULL)`},
		{`CREATE TABLE a (b INT PRIMARY KEY)`},
		{`CREATE TABLE a (b INT UNIQUE)`},
		{`CREATE TABLE a (b INT NULL PRIMARY KEY)`},
		{`CREATE TABLE a (b INT DEFAULT 1)`},
		{`CREATE TABLE a (b INT CONSTRAINT one DEFAULT 1)`},
		{`CREATE TABLE a (b INT DEFAULT now())`},
		{`CREATE TABLE a (a INT CHECK (a > 0))`},
		{`CREATE TABLE a (a INT CONSTRAINT positive CHECK (a > 0))`},
		{`CREATE TABLE a (a INT DEFAULT 1 CHECK (a > 0))`},
		{`CREATE TABLE a (a INT CONSTRAINT one DEFAULT 1 CHECK (a > 0))`},
		{`CREATE TABLE a (a INT DEFAULT 1 CONSTRAINT positive CHECK (a > 0))`},
		{`CREATE TABLE a (a INT CONSTRAINT one DEFAULT 1 CONSTRAINT positive CHECK (a > 0))`},
		{`CREATE TABLE a (a INT CONSTRAINT one CHECK (a > 0) CONSTRAINT two CHECK (a < 10))`},
		// "0" lost quotes previously.
		{`CREATE TABLE a (b INT, c TEXT, PRIMARY KEY (b, c, "0"))`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON UPDATE RESTRICT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE RESTRICT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE RESTRICT ON UPDATE RESTRICT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON UPDATE CASCADE)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE CASCADE)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE CASCADE ON UPDATE CASCADE)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON UPDATE SET NULL)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE SET NULL)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE SET NULL ON UPDATE SET NULL)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON UPDATE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE SET DEFAULT ON UPDATE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE RESTRICT ON UPDATE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE SET DEFAULT ON UPDATE CASCADE)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE CASCADE ON UPDATE SET NULL)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b) REFERENCES other ON DELETE SET NULL ON UPDATE RESTRICT)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b, c) REFERENCES other)`},
		{`CREATE TABLE a (b INT, c TEXT, FOREIGN KEY (b, c) REFERENCES other (x, y))`},
		{`CREATE TABLE a (b INT, c TEXT, CONSTRAINT s FOREIGN KEY (b, c) REFERENCES other (x, y))`},
		{`CREATE TABLE a (b INT, c TEXT, INDEX (b, c))`},
		{`CREATE TABLE a (b INT, c TEXT, INDEX d (b, c))`},
		{`CREATE TABLE a (b INT, c TEXT, CONSTRAINT d UNIQUE (b, c))`},
		{`CREATE TABLE a (b INT, c TEXT, CONSTRAINT d UNIQUE (b, c) INTERLEAVE IN PARENT d (e, f))`},
		{`CREATE TABLE a (b INT, UNIQUE (b))`},
		{`CREATE TABLE a (b INT, UNIQUE (b) STORING (c))`},
		{`CREATE TABLE a (b INT, INDEX (b))`},
		{`CREATE TABLE a (b INT, INVERTED INDEX (b))`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON UPDATE RESTRICT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE RESTRICT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE RESTRICT ON UPDATE RESTRICT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON UPDATE CASCADE)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE CASCADE)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE CASCADE ON UPDATE CASCADE)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON UPDATE SET NULL)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE SET NULL)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE SET NULL ON UPDATE SET NULL)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON UPDATE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE SET DEFAULT ON UPDATE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE RESTRICT ON UPDATE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE SET DEFAULT ON UPDATE CASCADE)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE CASCADE ON UPDATE SET NULL)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON DELETE SET NULL ON UPDATE RESTRICT)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON UPDATE CASCADE)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON UPDATE SET NULL)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo ON UPDATE SET DEFAULT)`},
		{`CREATE TABLE a (b INT, c INT CONSTRAINT ref REFERENCES foo)`},
		{`CREATE TABLE a (b INT, c INT REFERENCES foo (bar))`},
		{`CREATE TABLE a (b INT, INDEX (b) STORING (c))`},
		{`CREATE TABLE a (b INT, c TEXT, INDEX (b ASC, c DESC) STORING (c))`},
		{`CREATE TABLE a (b INT, INDEX (b) INTERLEAVE IN PARENT c (d, e))`},
		{`CREATE TABLE a (b INT, FAMILY (b))`},
		{`CREATE TABLE a (b INT, c STRING, FAMILY foo (b), FAMILY (c))`},
		{`CREATE TABLE a (b INT) INTERLEAVE IN PARENT foo (c, d)`},
		{`CREATE TABLE a (b INT) INTERLEAVE IN PARENT foo (c) CASCADE`},
		{`CREATE TABLE a.b (b INT)`},
		{`CREATE TABLE IF NOT EXISTS a (b INT)`},
		{`CREATE TABLE a (b INT AS (a + b) STORED)`},
		{`CREATE TABLE view (view INT)`},

		{`CREATE TABLE a (b INT) PARTITION BY LIST (b) (PARTITION p1 VALUES IN (1, DEFAULT), PARTITION p2 VALUES IN ((1, 2), (3, 4)))`},
		{`CREATE TABLE a (b INT) PARTITION BY RANGE (b) (PARTITION p1 VALUES FROM (MINVALUE) TO (1), PARTITION p2 VALUES FROM (2, MAXVALUE) TO (4, 4), PARTITION p3 VALUES FROM (4, 4) TO (MAXVALUE))`},
		// This monstrosity was added on the assumption that it's more readable
		// than all on one line. Feel free to rip it out if you come across it
		// and disagree.
		{regexp.MustCompile(`\n\s*`).ReplaceAllLiteralString(
			`CREATE TABLE a (b INT, c INT, d INT) PARTITION BY LIST (b) (
				PARTITION p1 VALUES IN (1) PARTITION BY LIST (c) (
					PARTITION p1_1 VALUES IN (3), PARTITION p1_2 VALUES IN (4, 5)
				), PARTITION p2 VALUES IN (6) PARTITION BY RANGE (c) (
					PARTITION p2_1 VALUES FROM (7) TO (8) PARTITION BY LIST (d) (
						PARTITION p2_1_1 VALUES IN (8)
					)
				)
			)`, ``),
		},
		{`CREATE TABLE a () INTERLEAVE IN PARENT b (c) PARTITION BY LIST (d) (PARTITION e VALUES IN (1))`},
		{`CREATE TABLE IF NOT EXISTS a () PARTITION BY LIST (b) (PARTITION c VALUES IN (1))`},
		{`CREATE TABLE a (INDEX (b) PARTITION BY LIST (c) (PARTITION d VALUES IN (1)))`},
		{`CREATE TABLE a (UNIQUE (b) PARTITION BY LIST (c) (PARTITION d VALUES IN (1)))`},
		{`CREATE INDEX ON a (b) PARTITION BY LIST (c) (PARTITION d VALUES IN (1))`},
		{`CREATE INDEX IF NOT EXISTS a ON b (c) PARTITION BY LIST (d) (PARTITION e VALUES IN (1))`},
		{`ALTER TABLE a PARTITION BY LIST (b) (PARTITION p1 VALUES IN (1))`},
		{`ALTER INDEX a@idx PARTITION BY LIST (b) (PARTITION p1 VALUES IN (1))`},

		{`CREATE TABLE a AS SELECT * FROM b`},
		{`CREATE TABLE IF NOT EXISTS a AS SELECT * FROM b`},
		{`CREATE TABLE a AS SELECT * FROM b ORDER BY c`},
		{`CREATE TABLE IF NOT EXISTS a AS SELECT * FROM b ORDER BY c`},
		{`CREATE TABLE a AS SELECT * FROM b LIMIT 3`},
		{`CREATE TABLE IF NOT EXISTS a AS SELECT * FROM b LIMIT 3`},
		{`CREATE TABLE a AS VALUES ('one', 1), ('two', 2), ('three', 3)`},
		{`CREATE TABLE IF NOT EXISTS a AS VALUES ('one', 1), ('two', 2), ('three', 3)`},
		{`CREATE TABLE a (str, num) AS VALUES ('one', 1), ('two', 2), ('three', 3)`},
		{`CREATE TABLE IF NOT EXISTS a (str, num) AS VALUES ('one', 1), ('two', 2), ('three', 3)`},
		{`CREATE TABLE a AS SELECT * FROM b UNION SELECT * FROM c`},
		{`CREATE TABLE IF NOT EXISTS a AS SELECT * FROM b UNION SELECT * FROM c`},
		{`CREATE TABLE a AS SELECT * FROM b UNION VALUES ('one', 1) ORDER BY c LIMIT 5`},
		{`CREATE TABLE IF NOT EXISTS a AS SELECT * FROM b UNION VALUES ('one', 1) ORDER BY c LIMIT 5`},
		{`CREATE TABLE a (b STRING COLLATE "DE")`},
		{`CREATE TABLE a (b STRING[] COLLATE "DE")`},

		{`CREATE VIEW a AS SELECT * FROM b`},
		{`CREATE VIEW a AS SELECT b.* FROM b LIMIT 5`},
		{`CREATE VIEW a AS (SELECT c, d FROM b WHERE c > 0 ORDER BY c)`},
		{`CREATE VIEW a (x, y) AS SELECT c, d FROM b`},
		{`CREATE VIEW a AS VALUES (1, 'one'), (2, 'two')`},
		{`CREATE VIEW a (x, y) AS VALUES (1, 'one'), (2, 'two')`},
		{`CREATE VIEW a AS TABLE b`},

		{`CREATE SEQUENCE a`},
		{`CREATE SEQUENCE IF NOT EXISTS a`},
		{`CREATE SEQUENCE a CYCLE`},
		{`CREATE SEQUENCE a NO CYCLE`},
		{`CREATE SEQUENCE a CACHE 0`},
		{`CREATE SEQUENCE a CACHE 1`},
		{`CREATE SEQUENCE a CACHE 2`},
		{`CREATE SEQUENCE a INCREMENT 5`},
		{`CREATE SEQUENCE a INCREMENT BY 5`},
		{`CREATE SEQUENCE a NO MAXVALUE`},
		{`CREATE SEQUENCE a MAXVALUE 1000`},
		{`CREATE SEQUENCE a NO MINVALUE`},
		{`CREATE SEQUENCE a MINVALUE 1000`},
		{`CREATE SEQUENCE a START 1000`},
		{`CREATE SEQUENCE a START WITH 1000`},
		{`CREATE SEQUENCE a INCREMENT 5 NO MAXVALUE MINVALUE 1 START 3`},
		{`CREATE SEQUENCE a INCREMENT 5 NO CYCLE NO MAXVALUE MINVALUE 1 START 3 CACHE 1`},

		{`CREATE STATISTICS a ON col1 FROM t`},
		{`CREATE STATISTICS a ON col1, col2 FROM t`},
		{`CREATE STATISTICS a ON col1 FROM d.t`},

		{`DELETE FROM a`},
		{`DELETE FROM a.b`},
		{`DELETE FROM a WHERE a = b`},
		{`DELETE FROM a WHERE a = b LIMIT c`},
		{`DELETE FROM a WHERE a = b ORDER BY c`},
		{`DELETE FROM a WHERE a = b ORDER BY c LIMIT d`},
		{`DELETE FROM a WHERE a = b RETURNING a, b`},
		{`DELETE FROM a WHERE a = b RETURNING 1, 2`},
		{`DELETE FROM a WHERE a = b RETURNING a + b`},
		{`DELETE FROM a WHERE a = b RETURNING NOTHING`},
		{`DELETE FROM a WHERE a = b ORDER BY c LIMIT d RETURNING e`},

		{`DISCARD ALL`},

		{`DROP DATABASE a`},
		{`DROP DATABASE IF EXISTS a`},
		{`DROP DATABASE a CASCADE`},
		{`DROP DATABASE a RESTRICT`},
		{`DROP TABLE a`},
		{`DROP TABLE a.b`},
		{`DROP TABLE a, b`},
		{`DROP TABLE IF EXISTS a`},
		{`DROP TABLE a RESTRICT`},
		{`DROP TABLE a.b RESTRICT`},
		{`DROP TABLE a, b RESTRICT`},
		{`DROP TABLE IF EXISTS a RESTRICT`},
		{`DROP TABLE a CASCADE`},
		{`DROP TABLE a.b CASCADE`},
		{`DROP TABLE a, b CASCADE`},
		{`DROP TABLE IF EXISTS a CASCADE`},
		{`DROP INDEX a.b@c`},
		{`DROP INDEX a`},
		{`DROP INDEX a.b`},
		{`DROP INDEX IF EXISTS a.b@c`},
		{`DROP INDEX a.b@c, d@f`},
		{`DROP INDEX IF EXISTS a.b@c, d@f`},
		{`DROP INDEX a.b@c CASCADE`},
		{`DROP INDEX IF EXISTS a.b@c RESTRICT`},
		{`DROP VIEW a`},
		{`DROP VIEW a.b`},
		{`DROP VIEW a, b`},
		{`DROP VIEW IF EXISTS a`},
		{`DROP VIEW a RESTRICT`},
		{`DROP VIEW IF EXISTS a, b RESTRICT`},
		{`DROP VIEW a.b CASCADE`},
		{`DROP VIEW a, b CASCADE`},
		{`DROP SEQUENCE a`},
		{`DROP SEQUENCE a.b`},
		{`DROP SEQUENCE a, b`},
		{`DROP SEQUENCE IF EXISTS a`},
		{`DROP SEQUENCE a RESTRICT`},
		{`DROP SEQUENCE IF EXISTS a, b RESTRICT`},
		{`DROP SEQUENCE a.b CASCADE`},
		{`DROP SEQUENCE a, b CASCADE`},

		{`CANCEL JOBS SELECT a`},
		{`CANCEL QUERIES SELECT a`},
		{`CANCEL SESSIONS SELECT a`},
		{`CANCEL QUERIES IF EXISTS SELECT a`},
		{`CANCEL SESSIONS IF EXISTS SELECT a`},
		{`RESUME JOBS SELECT a`},
		{`PAUSE JOBS SELECT a`},

		{`EXPLAIN SELECT 1`},
		{`EXPLAIN EXPLAIN SELECT 1`},
		{`EXPLAIN (A, B, C) SELECT 1`},
		{`EXPLAIN ANALYZE (A, B, C) SELECT 1`},
		{`SELECT * FROM [EXPLAIN SELECT 1]`},
		{`SELECT * FROM [SHOW TRANSACTION STATUS]`},

		{`SHOW barfoo`},
		{`SHOW database`},
		{`SHOW timezone`},
		{`SHOW "BLAH"`},

		{`SHOW CLUSTER SETTING a`},
		{`SHOW CLUSTER SETTING all`},

		{`SHOW DATABASES`},
		{`SHOW SCHEMAS`},
		{`SHOW SCHEMAS FROM a`},
		{`SHOW TABLES`},
		{`SHOW TABLES FROM a`},
		{`SHOW TABLES FROM a.b`},
		{`SHOW COLUMNS FROM a`},
		{`SHOW COLUMNS FROM a.b.c`},
		{`SHOW INDEXES FROM a`},
		{`SHOW INDEXES FROM a.b.c`},
		{`SHOW CONSTRAINTS FROM a`},
		{`SHOW CONSTRAINTS FROM a.b.c`},
		{`SHOW TABLES FROM a.b; SHOW COLUMNS FROM b`},
		{`SHOW ROLES`},
		{`SHOW USERS`},
		{`SHOW JOBS`},
		{`SHOW CLUSTER QUERIES`},
		{`SHOW LOCAL QUERIES`},
		{`SHOW CLUSTER SESSIONS`},
		{`SHOW LOCAL SESSIONS`},
		{`SHOW TRACE FOR SESSION`},
		{`SHOW KV TRACE FOR SESSION`},
		{`SHOW EXPERIMENTAL_REPLICA TRACE FOR SESSION`},
		{`SHOW STATISTICS FOR TABLE t`},
		{`SHOW STATISTICS FOR TABLE d.t`},
		{`SHOW HISTOGRAM 123`},
		{`SHOW EXPERIMENTAL_RANGES FROM TABLE d.t`},
		{`SHOW EXPERIMENTAL_RANGES FROM TABLE t`},
		{`SHOW EXPERIMENTAL_RANGES FROM INDEX d.t@i`},
		{`SHOW EXPERIMENTAL_RANGES FROM INDEX t@i`},
		{`SHOW EXPERIMENTAL_RANGES FROM INDEX d.i`},
		{`SHOW EXPERIMENTAL_RANGES FROM INDEX i`},
		{`SHOW EXPERIMENTAL_FINGERPRINTS FROM TABLE d.t`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATIONS`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR RANGE default`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR RANGE meta`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR DATABASE db`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR TABLE db.t`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR PARTITION p OF TABLE db.t`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR TABLE t`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR PARTITION p OF TABLE t`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR INDEX db.t@i`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR INDEX t@i`},
		{`EXPERIMENTAL SHOW ZONE CONFIGURATION FOR INDEX i`},

		// Tables are the default, but can also be specified with
		// GRANT x ON TABLE y. However, the stringer does not output TABLE.
		{`SHOW GRANTS`},
		{`SHOW GRANTS ON TABLE foo`},
		{`SHOW GRANTS ON TABLE foo, db.foo`},
		{`SHOW GRANTS ON DATABASE foo, bar`},
		{`SHOW GRANTS ON DATABASE foo FOR bar`},
		{`SHOW GRANTS FOR bar, baz`},

		{`SHOW GRANTS ON ROLE`},
		{`SHOW GRANTS ON ROLE foo`},
		{`SHOW GRANTS ON ROLE foo, bar`},
		{`SHOW GRANTS ON ROLE foo FOR bar`},
		{`SHOW GRANTS ON ROLE FOR bar, baz`},

		{`SHOW TRANSACTION STATUS`},

		{`SHOW SYNTAX 'select 1'`},

		{`PREPARE a AS SELECT 1`},
		{`PREPARE a (INT) AS SELECT $1`},
		{`PREPARE a (STRING, STRING) AS SELECT $1, $2`},
		{`PREPARE a AS INSERT INTO a VALUES (1)`},
		{`PREPARE a (INT) AS INSERT INTO a VALUES ($1)`},
		{`PREPARE a AS UPDATE a SET b = 1`},
		{`PREPARE a (INT) AS UPDATE a SET b = $1`},
		{`PREPARE a AS UPSERT INTO a VALUES (1)`},
		{`PREPARE a (INT) AS UPSERT INTO a VALUES ($1)`},
		{`PREPARE a AS DELETE FROM a`},
		{`PREPARE a (INT) AS DELETE FROM a WHERE b = $1`},
		{`PREPARE a AS BACKUP DATABASE a TO 'b'`},
		{`PREPARE a (STRING) AS BACKUP DATABASE a TO $1`},
		{`PREPARE a AS RESTORE DATABASE a FROM 'b'`},
		{`PREPARE a (STRING) AS RESTORE DATABASE a FROM $1`},
		{`PREPARE a AS CANCEL QUERIES SELECT 1`},
		{`PREPARE a (STRING) AS CANCEL QUERIES SELECT $1`},
		{`PREPARE a AS CANCEL QUERIES IF EXISTS SELECT 1`},
		{`PREPARE a (STRING) AS CANCEL QUERIES IF EXISTS SELECT $1`},
		{`PREPARE a AS CANCEL SESSIONS SELECT 1`},
		{`PREPARE a (STRING) AS CANCEL SESSIONS SELECT $1`},
		{`PREPARE a AS CANCEL SESSIONS IF EXISTS SELECT 1`},
		{`PREPARE a (STRING) AS CANCEL SESSIONS IF EXISTS SELECT $1`},
		{`PREPARE a AS CANCEL JOBS SELECT 1`},
		{`PREPARE a (INT) AS CANCEL JOBS SELECT $1`},
		{`PREPARE a AS PAUSE JOBS SELECT 1`},
		{`PREPARE a (INT) AS PAUSE JOBS SELECT $1`},
		{`PREPARE a AS RESUME JOBS SELECT 1`},
		{`PREPARE a (INT) AS RESUME JOBS SELECT $1`},
		{`PREPARE a AS IMPORT TABLE a CREATE USING 'b' CSV DATA ('c') WITH temp = 'd'`},
		{`PREPARE a (STRING, STRING, STRING) AS IMPORT TABLE a CREATE USING $1 CSV DATA ($2) WITH temp = $3`},

		{`EXECUTE a`},
		{`EXECUTE a (1)`},
		{`EXECUTE a (1, 1)`},
		{`EXECUTE a (1 + 1)`},

		{`DEALLOCATE a`},
		{`DEALLOCATE ALL`},

		// Tables are the default, but can also be specified with
		// GRANT x ON TABLE y. However, the stringer does not output TABLE.
		{`GRANT SELECT ON TABLE foo TO root`},
		{`GRANT SELECT, DELETE, UPDATE ON TABLE foo, db.foo TO root, bar`},
		{`GRANT DROP ON DATABASE foo TO root`},
		{`GRANT ALL ON DATABASE foo TO root, test`},
		{`GRANT SELECT, INSERT ON DATABASE bar TO foo, bar, baz`},
		{`GRANT SELECT, INSERT ON DATABASE db1, db2 TO foo, bar, baz`},
		{`GRANT SELECT, INSERT ON DATABASE db1, db2 TO "test-user"`},
		{`GRANT rolea, roleb TO usera, userb`},
		{`GRANT rolea, roleb TO usera, userb WITH ADMIN OPTION`},

		// Tables are the default, but can also be specified with
		// REVOKE x ON TABLE y. However, the stringer does not output TABLE.
		{`REVOKE SELECT ON TABLE foo FROM root`},
		{`REVOKE UPDATE, DELETE ON TABLE foo, db.foo FROM root, bar`},
		{`REVOKE INSERT ON DATABASE foo FROM root`},
		{`REVOKE ALL ON DATABASE foo FROM root, test`},
		{`REVOKE SELECT, INSERT ON DATABASE bar FROM foo, bar, baz`},
		{`REVOKE SELECT, INSERT ON DATABASE db1, db2 FROM foo, bar, baz`},
		{`REVOKE rolea, roleb FROM usera, userb`},
		{`REVOKE ADMIN OPTION FOR rolea, roleb FROM usera, userb`},

		{`INSERT INTO a VALUES (1)`},
		{`INSERT INTO a.b VALUES (1)`},
		{`INSERT INTO a VALUES (1, 2)`},
		{`INSERT INTO a VALUES (1, DEFAULT)`},
		{`INSERT INTO a VALUES (1, 2), (3, 4)`},
		{`INSERT INTO a VALUES (a + 1, 2 * 3)`},
		{`INSERT INTO a(a, b) VALUES (1, 2)`},
		{`INSERT INTO a SELECT b, c FROM d`},
		{`INSERT INTO a DEFAULT VALUES`},
		{`INSERT INTO a VALUES (1) RETURNING a, b`},
		{`INSERT INTO a VALUES (1, 2) RETURNING 1, 2`},
		{`INSERT INTO a VALUES (1, 2) RETURNING a + b, c`},
		{`INSERT INTO a VALUES (1, 2) RETURNING NOTHING`},

		{`UPSERT INTO a VALUES (1)`},
		{`UPSERT INTO a.b VALUES (1)`},
		{`UPSERT INTO a VALUES (1, 2)`},
		{`UPSERT INTO a VALUES (1, DEFAULT)`},
		{`UPSERT INTO a VALUES (1, 2), (3, 4)`},
		{`UPSERT INTO a VALUES (a + 1, 2 * 3)`},
		{`UPSERT INTO a(a, b) VALUES (1, 2)`},
		{`UPSERT INTO a SELECT b, c FROM d`},
		{`UPSERT INTO a DEFAULT VALUES`},
		{`UPSERT INTO a DEFAULT VALUES RETURNING a, b`},
		{`UPSERT INTO a DEFAULT VALUES RETURNING 1, 2`},
		{`UPSERT INTO a DEFAULT VALUES RETURNING a + b`},
		{`UPSERT INTO a DEFAULT VALUES RETURNING NOTHING`},

		{`INSERT INTO a VALUES (1) ON CONFLICT DO NOTHING`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO NOTHING`},
		{`INSERT INTO a VALUES (1) ON CONFLICT DO UPDATE SET a = 1`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET a = 1`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a, b) DO UPDATE SET a = 1`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET a = 1, b = excluded.a`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET a = 1 WHERE b > 2`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET a = DEFAULT`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET (a, b) = (SELECT 1, 2)`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET (a, b) = (SELECT 1, 2) RETURNING a, b`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET (a, b) = (SELECT 1, 2) RETURNING 1, 2`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET (a, b) = (SELECT 1, 2) RETURNING a + b`},
		{`INSERT INTO a VALUES (1) ON CONFLICT (a) DO UPDATE SET (a, b) = (SELECT 1, 2) RETURNING NOTHING`},

		{`SELECT 1 + 1`},
		{`SELECT -1`},
		{`SELECT +1`},
		{`SELECT .1`},
		{`SELECT 1.2e1`},
		{`SELECT 1.2e+1`},
		{`SELECT 1.2e-1`},
		{`SELECT true AND false`},
		{`SELECT true AND NULL`},
		{`SELECT true = false`},
		{`SELECT (true = false)`},
		{`SELECT (ARRAY['a', 'b'])[2]`},
		{`SELECT (ARRAY (VALUES (1), (2)))[1]`},
		{`SELECT (SELECT 1)`},
		{`SELECT ((SELECT 1))`},
		{`SELECT (SELECT ARRAY['a', 'b'])[2]`},
		{`SELECT ((SELECT ARRAY['a', 'b']))[2]`},
		{`SELECT ((((VALUES (1)))))`},
		{`SELECT EXISTS (SELECT 1)`},
		{`SELECT (VALUES (1))`},
		{`SELECT (1, 2, 3)`},
		{`SELECT ((1, 2, 3) AS a, b, c)`},
		{`SELECT (ROW(1, 2, 3))`},
		{`SELECT (ROW(1, 2, 3) AS a, b, c)`},
		{`SELECT ((ROW(1, 2, 3) AS a, b, c)).a`},
		{`SELECT ((ROW(1, 2, 3) AS a, b, c)).*`},
		{`SELECT (ROW())`},
		{`SELECT (ROW() AS a)`},
		{`SELECT ((ROW() AS a)).a`},
		{`SELECT ((ROW() AS a)).*`},
		{`SELECT (TABLE a)`},
		{`SELECT 0x1`},
		{`SELECT 'Deutsch' COLLATE "DE"`},
		{`SELECT a @> b`},
		{`SELECT a <@ b`},
		{`SELECT a ? b`},
		{`SELECT a ?| b`},
		{`SELECT a ?& b`},
		{`SELECT a->'x'`},
		{`SELECT a#>'{x}'`},
		{`SELECT a#>>'{x}'`},
		{`SELECT (a->'x')->'y'`},
		{`SELECT (a->'x')->>'y'`},
		{`SELECT ''::JSON`},
		{`SELECT ''::JSONB`},

		{`SELECT 1 FROM t`},
		{`SELECT 1, 2 FROM t`},
		{`SELECT * FROM t`},
		{`SELECT "*" FROM t`},
		{`SELECT a, b FROM t`},
		{`SELECT a AS b FROM t`},
		{`SELECT a.* FROM t`},
		{`SELECT a = b FROM t`},
		{`SELECT $1 FROM t`},
		{`SELECT $1, $2 FROM t`},
		{`SELECT NULL FROM t`},
		{`SELECT 0.1 FROM t`},
		{`SELECT a FROM t`},
		{`SELECT a.b FROM t`},
		{`SELECT a.b.* FROM t`},
		{`SELECT a.b[1] FROM t`},
		{`SELECT a.b[1 + 1:4][3] FROM t`},
		{`SELECT a.b[:4][3] FROM t`},
		{`SELECT a.b[1 + 1:][3] FROM t`},
		{`SELECT a.b[:][3] FROM t`},
		{`SELECT 'a' FROM t`},
		{`SELECT 'a' FROM t@bar`},
		{`SELECT 'a' FROM t@primary`},
		{`SELECT 'a' FROM t@like`},
		{`SELECT 'a' FROM t@{NO_INDEX_JOIN}`},
		{`SELECT 'a' FROM t@{FORCE_INDEX=bar,NO_INDEX_JOIN}`},
		{`SELECT * FROM t AS "of" AS OF SYSTEM TIME '2016-01-01'`},

		{`SELECT BOOL 'foo'`},
		{`SELECT INT 'foo'`},
		{`SELECT REAL 'foo'`},
		{`SELECT DECIMAL 'foo'`},
		{`SELECT BIT '1'`},
		{`SELECT CHAR 'foo'`},
		{`SELECT VARCHAR 'foo'`},
		{`SELECT STRING 'foo'`},
		{`SELECT BYTES 'foo'`},
		{`SELECT DATE 'foo'`},
		{`SELECT TIME 'foo'`},
		{`SELECT TIME WITH TIME ZONE 'foo'`},
		{`SELECT TIMESTAMP 'foo'`},
		{`SELECT TIMESTAMP WITH TIME ZONE 'foo'`},

		{`SELECT '1'::INT`},
		{`SELECT '1'::SERIAL`},
		{`SELECT '1':::INT`},
		{`SELECT '1':::SERIAL`},
		{`SELECT INT '1'`},
		{`SELECT SERIAL '1'`},

		{`SELECT 'foo'::JSON`},
		{`SELECT 'foo'::JSONB`},
		{`SELECT 'foo':::JSON`},
		{`SELECT 'foo':::JSONB`},
		{`SELECT JSON 'foo'`},
		{`SELECT JSONB 'foo'`},

		{`SELECT '192.168.0.1'::INET`},
		{`SELECT '192.168.0.1':::INET`},
		{`SELECT INET '192.168.0.1'`},

		{`SELECT 'a' AS "12345"`},
		{`SELECT 'a' AS clnm`},
		{`SELECT 'a' AS primary`},
		{`SELECT 'a' AS like`},

		{`SELECT 0xf0 FROM t`},
		{`SELECT 0xF0 FROM t`},

		// Escaping may change since the scanning process loses information
		// (you can write e'\'' or ''''), but these are the idempotent cases.
		// Generally, anything that needs to escape plus \ and ' leads to an
		// escaped string.
		{`SELECT e'a\'a' FROM t`},
		{`SELECT e'a\\\\na' FROM t`},
		{`SELECT e'\\\\n' FROM t`},
		{`SELECT "a""a" FROM t`},
		{`SELECT a FROM "t\n"`},  // no escaping in sql identifiers
		{`SELECT a FROM "t"""`},  // no escaping in sql identifiers
		{`SELECT "full" FROM t`}, // must quote column name keyword

		{`SELECT "FROM" FROM t`},
		{`SELECT CAST(1 AS TEXT)`},
		{`SELECT ANNOTATE_TYPE(1, TEXT)`},
		{`SELECT a FROM t AS bar`},
		{`SELECT a FROM t AS bar (bar1)`},
		{`SELECT a FROM t AS bar (bar1, bar2, bar3)`},
		{`SELECT a FROM t WITH ORDINALITY`},
		{`SELECT a FROM t WITH ORDINALITY AS bar`},
		{`SELECT a FROM (SELECT 1 FROM t)`},
		{`SELECT a FROM (SELECT 1 FROM t) AS bar`},
		{`SELECT a FROM (SELECT 1 FROM t) AS bar (bar1)`},
		{`SELECT a FROM (SELECT 1 FROM t) AS bar (bar1, bar2, bar3)`},
		{`SELECT a FROM (SELECT 1 FROM t) WITH ORDINALITY`},
		{`SELECT a FROM (SELECT 1 FROM t) WITH ORDINALITY AS bar`},
		{`SELECT a FROM ROWS FROM (a(x), b(y), c(z))`},
		{`SELECT a FROM t1, t2`},
		{`SELECT a FROM t AS t1`},
		{`SELECT a FROM t AS t1 (c1)`},
		{`SELECT a FROM t AS t1 (c1, c2, c3, c4)`},
		{`SELECT a FROM s.t`},

		{`SELECT count(DISTINCT a) FROM t`},
		{`SELECT count(ALL a) FROM t`},

		{`SELECT a FROM t WHERE a = b`},
		{`SELECT a FROM t WHERE NOT (a = b)`},
		{`SELECT a FROM t WHERE EXISTS (SELECT 1 FROM t)`},
		{`SELECT a FROM t WHERE NOT true`},
		{`SELECT a FROM t WHERE NOT false`},
		{`SELECT a FROM t WHERE a IN (b)`},
		{`SELECT a FROM t WHERE a IN (b, c)`},
		{`SELECT a FROM t WHERE a IN (SELECT a FROM t)`},
		{`SELECT a FROM t WHERE a NOT IN (b, c)`},
		{`SELECT a FROM t WHERE a = ANY (ARRAY[b, c])`},
		{`SELECT a FROM t WHERE a = ANY ARRAY[b, c]`},
		{`SELECT a FROM t WHERE a != SOME (ARRAY[b, c])`},
		{`SELECT a FROM t WHERE a != SOME ARRAY[b, c]`},
		{`SELECT a FROM t WHERE a = ANY (SELECT 1)`},
		{`SELECT a FROM t WHERE a LIKE ALL (ARRAY[b, c])`},
		{`SELECT a FROM t WHERE a LIKE ALL ARRAY[b, c]`},
		{`SELECT a FROM t WHERE a LIKE b`},
		{`SELECT a FROM t WHERE a NOT LIKE b`},
		{`SELECT a FROM t WHERE a ILIKE b`},
		{`SELECT a FROM t WHERE a NOT ILIKE b`},
		{`SELECT a FROM t WHERE a SIMILAR TO b`},
		{`SELECT a FROM t WHERE a NOT SIMILAR TO b`},
		{`SELECT a FROM t WHERE a ~ b`},
		{`SELECT a FROM t WHERE a !~ b`},
		{`SELECT a FROM t WHERE a ~* c`},
		{`SELECT a FROM t WHERE a !~* c`},
		{`SELECT a FROM t WHERE a BETWEEN b AND c`},
		{`SELECT a FROM t WHERE a BETWEEN SYMMETRIC b AND c`},
		{`SELECT a FROM t WHERE a NOT BETWEEN b AND c`},
		{`SELECT a FROM t WHERE a NOT BETWEEN SYMMETRIC b AND c`},
		{`SELECT a FROM t WHERE a IS NULL`},
		{`SELECT a FROM t WHERE a IS NOT NULL`},
		{`SELECT a FROM t WHERE a IS true`},
		{`SELECT a FROM t WHERE a IS NOT true`},
		{`SELECT a FROM t WHERE a IS false`},
		{`SELECT a FROM t WHERE a IS NOT false`},
		{`SELECT a FROM t WHERE a IS OF (INT)`},
		{`SELECT a FROM t WHERE a IS NOT OF (FLOAT, STRING)`},
		{`SELECT a FROM t WHERE a IS DISTINCT FROM b`},
		{`SELECT a FROM t WHERE a IS NOT DISTINCT FROM b`},
		{`SELECT a FROM t WHERE a < b`},
		{`SELECT a FROM t WHERE a <= b`},
		{`SELECT a FROM t WHERE a >= b`},
		{`SELECT a FROM t WHERE a != b`},
		{`SELECT a FROM t WHERE a = (SELECT a FROM t)`},
		{`SELECT a FROM t WHERE a = (b)`},
		{`SELECT a FROM t WHERE CASE WHEN a = b THEN c END`},
		{`SELECT a FROM t WHERE CASE WHEN a = b THEN c ELSE d END`},
		{`SELECT a FROM t WHERE CASE WHEN a = b THEN c WHEN b = d THEN d ELSE d END`},
		{`SELECT a FROM t WHERE CASE aa WHEN a = b THEN c END`},
		{`SELECT a FROM t WHERE a = b()`},
		{`SELECT a FROM t WHERE a = b(c)`},
		{`SELECT a FROM t WHERE a = b(c, d)`},
		{`SELECT a FROM t WHERE a = count(*)`},
		{`SELECT a FROM t WHERE a = IF(b, c, d)`},
		{`SELECT a FROM t WHERE a = IFERROR(b, c, d)`},
		{`SELECT a FROM t WHERE a = IFERROR(b, c)`},
		{`SELECT a FROM t WHERE a = ISERROR(b)`},
		{`SELECT a FROM t WHERE a = ISERROR(b, c)`},
		{`SELECT a FROM t WHERE a = IFNULL(b, c)`},
		{`SELECT a FROM t WHERE a = NULLIF(b, c)`},
		{`SELECT a FROM t WHERE a = COALESCE(a, b, c, d, e)`},
		{`SELECT (a.b) FROM t WHERE (b.c) = 2`},

		{`SELECT a FROM t ORDER BY a`},
		{`SELECT a FROM t ORDER BY a ASC`},
		{`SELECT a FROM t ORDER BY a DESC`},
		{`SELECT a FROM t ORDER BY PRIMARY KEY t`},
		{`SELECT a FROM t ORDER BY PRIMARY KEY t ASC`},
		{`SELECT a FROM t ORDER BY PRIMARY KEY t DESC`},
		{`SELECT a FROM t ORDER BY INDEX t@foo`},
		{`SELECT a FROM t ORDER BY INDEX t@foo ASC`},
		{`SELECT a FROM t ORDER BY INDEX t@foo DESC`},
		{`SELECT a FROM t ORDER BY INDEX t@primary`},
		{`SELECT a FROM t ORDER BY INDEX t@like`},

		{`SELECT 1 FROM t GROUP BY a`},
		{`SELECT 1 FROM t GROUP BY a, b`},

		{`SELECT a FROM t HAVING a = b`},

		{`SELECT a FROM t WINDOW w AS ()`},
		{`SELECT a FROM t WINDOW w AS (w2)`},
		{`SELECT a FROM t WINDOW w AS (PARTITION BY b)`},
		{`SELECT a FROM t WINDOW w AS (PARTITION BY b, 1 + 2)`},
		{`SELECT a FROM t WINDOW w AS (ORDER BY c)`},
		{`SELECT a FROM t WINDOW w AS (ORDER BY c, 1 + 2)`},
		{`SELECT a FROM t WINDOW w AS (PARTITION BY b ORDER BY c)`},

		{`SELECT avg(1) OVER w FROM t`},
		{`SELECT avg(1) OVER () FROM t`},
		{`SELECT avg(1) OVER (w) FROM t`},
		{`SELECT avg(1) OVER (PARTITION BY b) FROM t`},
		{`SELECT avg(1) OVER (ORDER BY c) FROM t`},
		{`SELECT avg(1) OVER (PARTITION BY b ORDER BY c) FROM t`},
		{`SELECT avg(1) OVER (w PARTITION BY b ORDER BY c) FROM t`},

		{`SELECT avg(1) OVER (ROWS UNBOUNDED PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (ROWS 1 PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (ROWS CURRENT ROW) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND 1 PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND 1 FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN 1 PRECEDING AND 1 PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN CURRENT ROW AND CURRENT ROW) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN 1 FOLLOWING AND 1 FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (ROWS BETWEEN 1 FOLLOWING AND UNBOUNDED FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (RANGE UNBOUNDED PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (RANGE CURRENT ROW) FROM t`},
		{`SELECT avg(1) OVER (RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) FROM t`},
		{`SELECT avg(1) OVER (RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (RANGE BETWEEN CURRENT ROW AND CURRENT ROW) FROM t`},
		{`SELECT avg(1) OVER (RANGE BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) FROM t`},
		{`SELECT avg(1) OVER (w ROWS UNBOUNDED PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (PARTITION BY b ROWS UNBOUNDED PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (ORDER BY c ROWS UNBOUNDED PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (PARTITION BY b ORDER BY c ROWS UNBOUNDED PRECEDING) FROM t`},
		{`SELECT avg(1) OVER (w PARTITION BY b ORDER BY c ROWS UNBOUNDED PRECEDING) FROM t`},

		{`SELECT a FROM t UNION SELECT 1 FROM t`},
		{`SELECT a FROM t UNION SELECT 1 FROM t UNION SELECT 1 FROM t`},
		{`SELECT a FROM t UNION ALL SELECT 1 FROM t`},
		{`SELECT a FROM t EXCEPT SELECT 1 FROM t`},
		{`SELECT a FROM t EXCEPT ALL SELECT 1 FROM t`},
		{`SELECT a FROM t INTERSECT SELECT 1 FROM t`},
		{`SELECT a FROM t INTERSECT ALL SELECT 1 FROM t`},

		{`SELECT a FROM t1 JOIN t2 ON a = b`},
		{`SELECT a FROM t1 JOIN t2 USING (a)`},
		{`SELECT a FROM t1 LEFT JOIN t2 ON a = b`},
		{`SELECT a FROM t1 RIGHT JOIN t2 ON a = b`},
		{`SELECT a FROM t1 INNER JOIN t2 ON a = b`},
		{`SELECT a FROM t1 CROSS JOIN t2`},
		{`SELECT a FROM t1 NATURAL JOIN t2`},
		{`SELECT a FROM t1 INNER JOIN t2 USING (a)`},
		{`SELECT a FROM t1 FULL JOIN t2 USING (a)`},
		{`SELECT * FROM (t1 WITH ORDINALITY AS o1 CROSS JOIN t2 WITH ORDINALITY AS o2) WITH ORDINALITY AS o3`},

		{`SELECT a FROM t1 AS OF SYSTEM TIME '2016-01-01'`},
		{`SELECT a FROM t1, t2 AS OF SYSTEM TIME '2016-01-01'`},
		{`SELECT a FROM t1 AS OF SYSTEM TIME -('a' || 'b')::INTERVAL`},

		{`SELECT a FROM t LIMIT a`},
		{`SELECT a FROM t OFFSET b`},
		{`SELECT a FROM t LIMIT a OFFSET b`},
		{`SELECT DISTINCT * FROM t`},
		{`SELECT DISTINCT a, b FROM t`},
		{`SELECT DISTINCT ON (a, b) c FROM t`},
		{`SET a = 3`},
		{`SET a = 3, 4`},
		{`SET a = '3'`},
		{`SET a = 3.0`},
		{`SET a = $1`},
		{`SET a = off`},
		{`SET TRANSACTION READ ONLY`},
		{`SET TRANSACTION READ WRITE`},
		{`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE`},
		{`SET TRANSACTION PRIORITY LOW`},
		{`SET TRANSACTION PRIORITY NORMAL`},
		{`SET TRANSACTION PRIORITY HIGH`},
		{`SET TRANSACTION ISOLATION LEVEL SERIALIZABLE, PRIORITY HIGH`},
		{`SET TRACING = off`},
		{`SET TRACING = 'cluster', 'kv'`},
		{`SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL SERIALIZABLE`},
		{`SET CLUSTER SETTING a = 3`},
		{`SET CLUSTER SETTING a = '3s'`},
		{`SET CLUSTER SETTING a = '3'`},
		{`SET CLUSTER SETTING a = 3.0`},
		{`SET CLUSTER SETTING a = $1`},
		{`SET CLUSTER SETTING a = off`},

		{`SELECT * FROM (VALUES (1, 2)) AS foo`},
		{`SELECT * FROM (VALUES (1, 2)) AS foo (a, b)`},

		{`SELECT * FROM [123 AS t]`},
		{`SELECT * FROM [123(1, 2, 3) AS t]`},
		{`SELECT * FROM [123() AS t]`},
		{`SELECT * FROM t@[123]`},
		{`SELECT * FROM t@{FORCE_INDEX=[123],NO_INDEX_JOIN}`},
		{`SELECT * FROM [123 AS t]@[456]`},
		{`SELECT * FROM [123 AS t]@{FORCE_INDEX=[456],NO_INDEX_JOIN}`},

		{`SELECT (1 + 2).*`},
		{`SELECT (1 + 2).col`},
		{`SELECT (abc.def).col`},
		{`SELECT (i.keys).col`},
		{`SELECT (i.keys).*`},
		{`SELECT (ARRAY['a', 'b', 'c']).name`},

		{`TABLE a`}, // Shorthand for: SELECT * FROM a; used e.g. in CREATE VIEW v AS TABLE t
		{`TABLE [123 AS a]`},

		{`TRUNCATE TABLE a`},
		{`TRUNCATE TABLE a, b.c`},
		{`TRUNCATE TABLE a CASCADE`},

		{`UPDATE a SET b = 3`},
		{`UPDATE a.b SET b = 3`},
		{`UPDATE a SET b = 3, c = DEFAULT`},
		{`UPDATE a SET b = 3 + 4`},
		{`UPDATE a SET (b, c) = (3, DEFAULT)`},
		{`UPDATE a SET (b, c) = (SELECT 3, 4)`},
		{`UPDATE a SET b = 3 WHERE a = b`},
		{`UPDATE a SET b = 3 WHERE a = b LIMIT c`},
		{`UPDATE a SET b = 3 WHERE a = b ORDER BY c`},
		{`UPDATE a SET b = 3 WHERE a = b ORDER BY c LIMIT d`},
		{`UPDATE a SET b = 3 WHERE a = b RETURNING a`},
		{`UPDATE a SET b = 3 WHERE a = b RETURNING 1, 2`},
		{`UPDATE a SET b = 3 WHERE a = b RETURNING a, a + b`},
		{`UPDATE a SET b = 3 WHERE a = b RETURNING NOTHING`},
		{`UPDATE a SET b = 3 WHERE a = b ORDER BY c LIMIT d RETURNING e`},

		{`UPDATE t AS "0" SET k = ''`},                 // "0" lost its quotes
		{`SELECT * FROM "0" JOIN "0" USING (id, "0")`}, // last "0" lost its quotes.

		{`ALTER DATABASE a RENAME TO b`},
		{`ALTER TABLE a RENAME TO b`},
		{`ALTER TABLE IF EXISTS a RENAME TO b`},
		{`ALTER INDEX a@b RENAME TO b`},
		{`ALTER INDEX b RENAME TO b`},
		{`ALTER INDEX a@primary RENAME TO like`},
		{`ALTER INDEX IF EXISTS a@b RENAME TO b`},
		{`ALTER INDEX IF EXISTS a@primary RENAME TO like`},
		{`ALTER TABLE a RENAME COLUMN c1 TO c2`},
		{`ALTER TABLE IF EXISTS a RENAME COLUMN c1 TO c2`},

		{`ALTER TABLE a ADD COLUMN b INT, ADD CONSTRAINT a_idx UNIQUE (a)`},
		{`ALTER TABLE a ADD COLUMN IF NOT EXISTS b INT, ADD CONSTRAINT a_idx UNIQUE (a)`},
		{`ALTER TABLE IF EXISTS a ADD COLUMN b INT, ADD CONSTRAINT a_idx UNIQUE (a)`},
		{`ALTER TABLE IF EXISTS a ADD COLUMN IF NOT EXISTS b INT, ADD CONSTRAINT a_idx UNIQUE (a)`},
		{`ALTER TABLE a ADD COLUMN b INT, ADD CONSTRAINT a_idx UNIQUE (a)`},
		{`ALTER TABLE a ADD COLUMN IF NOT EXISTS b INT, ADD CONSTRAINT a_idx UNIQUE (a) NOT VALID`},
		{`ALTER TABLE IF EXISTS a ADD COLUMN b INT, ADD CONSTRAINT a_idx UNIQUE (a)`},
		{`ALTER TABLE IF EXISTS a ADD COLUMN IF NOT EXISTS b INT, ADD CONSTRAINT a_idx UNIQUE (a)`},
		{`ALTER TABLE a ADD COLUMN b INT FAMILY fam_a`},
		{`ALTER TABLE a ADD COLUMN b INT CREATE FAMILY`},
		{`ALTER TABLE a ADD COLUMN b INT CREATE FAMILY fam_b`},
		{`ALTER TABLE a ADD COLUMN b INT CREATE IF NOT EXISTS FAMILY fam_b`},

		{`ALTER TABLE a DROP COLUMN b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE a DROP COLUMN IF EXISTS b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE IF EXISTS a DROP COLUMN b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE IF EXISTS a DROP COLUMN IF EXISTS b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE a DROP COLUMN b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE a DROP COLUMN IF EXISTS b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE IF EXISTS a DROP COLUMN b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE IF EXISTS a DROP COLUMN IF EXISTS b, DROP CONSTRAINT a_idx`},
		{`ALTER TABLE a DROP COLUMN b CASCADE`},
		{`ALTER TABLE a DROP COLUMN b RESTRICT`},
		{`ALTER TABLE a DROP CONSTRAINT b CASCADE`},
		{`ALTER TABLE a DROP CONSTRAINT IF EXISTS b RESTRICT`},
		{`ALTER TABLE a VALIDATE CONSTRAINT a`},

		{`ALTER TABLE a ALTER COLUMN b SET DEFAULT 42`},
		{`ALTER TABLE a ALTER COLUMN b SET DEFAULT NULL`},
		{`ALTER TABLE a ALTER COLUMN b DROP DEFAULT`},
		{`ALTER TABLE a ALTER COLUMN b DROP NOT NULL`},
		{`ALTER TABLE a ALTER COLUMN b DROP STORED`},

		{`ALTER TABLE a ALTER COLUMN b SET DATA TYPE INT`},
		{`ALTER TABLE a ALTER COLUMN b SET DATA TYPE STRING COLLATE en USING b::STRING`},
		{`ALTER TABLE a ALTER COLUMN b SET DATA TYPE DECIMAL(10)[]`},

		{`COPY t FROM STDIN`},
		{`COPY t (a, b, c) FROM STDIN`},

		{`ALTER TABLE a SPLIT AT VALUES (1)`},
		{`ALTER TABLE a SPLIT AT SELECT * FROM t`},
		{`ALTER TABLE d.a SPLIT AT VALUES ('b', 2)`},
		{`ALTER INDEX a@i SPLIT AT VALUES (1)`},
		{`ALTER INDEX d.a@i SPLIT AT VALUES (2)`},
		{`ALTER INDEX i SPLIT AT VALUES (1)`},
		{`ALTER INDEX d.i SPLIT AT VALUES (2)`},

		{`ALTER TABLE a EXPERIMENTAL_RELOCATE VALUES (ARRAY[1], 1)`},
		{`ALTER TABLE a EXPERIMENTAL_RELOCATE SELECT * FROM t`},
		{`ALTER TABLE d.a EXPERIMENTAL_RELOCATE VALUES (ARRAY[1, 2, 3], 'b', 2)`},
		{`ALTER INDEX d.i EXPERIMENTAL_RELOCATE VALUES (ARRAY[1], 2)`},

		{`ALTER TABLE a EXPERIMENTAL_RELOCATE LEASE VALUES (1, 1)`},
		{`ALTER TABLE a EXPERIMENTAL_RELOCATE LEASE SELECT * FROM t`},
		{`ALTER TABLE d.a EXPERIMENTAL_RELOCATE LEASE VALUES (1, 'b', 2)`},
		{`ALTER INDEX d.i EXPERIMENTAL_RELOCATE LEASE VALUES (1, 2)`},

		{`ALTER TABLE a SCATTER`},
		{`ALTER TABLE a SCATTER FROM (1, 2, 3) TO (4, 5, 6)`},
		{`ALTER TABLE d.a SCATTER`},
		{`ALTER INDEX d.i SCATTER FROM (1) TO (2)`},

		{`ALTER RANGE default EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER RANGE meta EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER DATABASE db EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER TABLE db.t EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER PARTITION p OF TABLE db.t EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER TABLE t EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER PARTITION p OF TABLE t EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER INDEX db.t@i EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER INDEX t@i EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER INDEX i EXPERIMENTAL CONFIGURE ZONE 'foo'`},
		{`ALTER TABLE t EXPERIMENTAL CONFIGURE ZONE b'foo'`},
		{`ALTER TABLE t EXPERIMENTAL CONFIGURE ZONE NULL`},
		{`ALTER TABLE t EXPERIMENTAL CONFIGURE ZONE a || b`},
		{`ALTER TABLE t EXPERIMENTAL_AUDIT SET READ WRITE`},
		{`ALTER TABLE t EXPERIMENTAL_AUDIT SET OFF`},

		{`ALTER SEQUENCE a RENAME TO b`},
		{`ALTER SEQUENCE IF EXISTS a RENAME TO b`},
		{`ALTER SEQUENCE a INCREMENT BY 5 START WITH 1000`},
		{`ALTER SEQUENCE IF EXISTS a INCREMENT BY 5 START WITH 1000`},
		{`ALTER SEQUENCE IF EXISTS a NO CYCLE CACHE 1`},

		{`EXPERIMENTAL SCRUB DATABASE x`},
		{`EXPERIMENTAL SCRUB DATABASE x AS OF SYSTEM TIME 1`},
		{`EXPERIMENTAL SCRUB TABLE x`},
		{`EXPERIMENTAL SCRUB TABLE x AS OF SYSTEM TIME 1`},
		{`EXPERIMENTAL SCRUB TABLE x AS OF SYSTEM TIME 1 WITH OPTIONS INDEX ALL`},
		{`EXPERIMENTAL SCRUB TABLE x WITH OPTIONS INDEX (index_name)`},
		{`EXPERIMENTAL SCRUB TABLE x WITH OPTIONS PHYSICAL`},
		{`EXPERIMENTAL SCRUB TABLE x WITH OPTIONS CONSTRAINT ALL`},
		{`EXPERIMENTAL SCRUB TABLE x WITH OPTIONS CONSTRAINT (cst_name)`},
		{`EXPERIMENTAL SCRUB TABLE x WITH OPTIONS PHYSICAL, INDEX (index_name), CONSTRAINT (cst_name)`},
		{`EXPERIMENTAL SCRUB TABLE x WITH OPTIONS PHYSICAL, INDEX ALL, CONSTRAINT ALL`},

		{`BACKUP TABLE foo TO 'bar'`},
		{`BACKUP TABLE foo.foo, baz.baz TO 'bar'`},
		{`SHOW BACKUP 'bar'`},
		{`SHOW BACKUP RANGES 'bar'`},
		{`SHOW BACKUP FILES 'bar'`},
		{`BACKUP TABLE foo TO 'bar' AS OF SYSTEM TIME '1' INCREMENTAL FROM 'baz'`},
		{`BACKUP TABLE foo TO $1 INCREMENTAL FROM 'bar', $2, 'baz'`},
		{`BACKUP DATABASE foo TO 'bar'`},
		{`BACKUP DATABASE foo, baz TO 'bar'`},
		{`BACKUP DATABASE foo TO 'bar' AS OF SYSTEM TIME '1' INCREMENTAL FROM 'baz'`},
		{`RESTORE TABLE foo FROM 'bar'`},
		{`RESTORE TABLE foo FROM $1`},
		{`RESTORE TABLE foo FROM $1, $2, 'bar'`},
		{`RESTORE TABLE foo, baz FROM 'bar'`},
		{`RESTORE TABLE foo, baz FROM 'bar' AS OF SYSTEM TIME '1'`},
		{`RESTORE DATABASE foo FROM 'bar'`},
		{`RESTORE DATABASE foo, baz FROM 'bar'`},
		{`RESTORE DATABASE foo, baz FROM 'bar' AS OF SYSTEM TIME '1'`},
		{`BACKUP TABLE foo TO 'bar' WITH key1, key2 = 'value'`},
		{`RESTORE TABLE foo FROM 'bar' WITH key1, key2 = 'value'`},
		{`IMPORT TABLE foo CREATE USING 'nodelocal:///some/file' CSV DATA ('path/to/some/file', $1) WITH temp = 'path/to/temp'`},
		{`IMPORT TABLE foo CREATE USING 'nodelocal:///some/file' MYSQLOUTFILE DATA ('path/to/some/file', $1)`},
		{`IMPORT TABLE foo (id INT PRIMARY KEY, email STRING, age INT) CSV DATA ('path/to/some/file', $1) WITH temp = 'path/to/temp'`},
		{`IMPORT TABLE foo (id INT, email STRING, age INT) CSV DATA ('path/to/some/file', $1) WITH comma = ',', "nullif" = 'n/a', temp = $2`},
		{`EXPORT INTO CSV 'a' FROM TABLE a`},
		{`EXPORT INTO CSV 'a' FROM SELECT * FROM a`},
		{`EXPORT INTO CSV 's3://my/path/%part%.csv' WITH delimiter = '|' FROM TABLE a`},
		{`EXPORT INTO CSV 's3://my/path/%part%.csv' WITH delimiter = '|' FROM SELECT a, sum(b) FROM c WHERE d = 1 ORDER BY sum(b) DESC LIMIT 10`},
		{`SET ROW (1, true, NULL)`},

		{`CREATE CHANGEFEED FOR TABLE foo`},
		{`CREATE CHANGEFEED FOR TABLE foo INTO 'sink'`},
		// TODO(dan): Implement.
		// {`CREATE CHANGEFEED FOR TABLE foo VALUES FROM (1) TO (2) INTO 'sink'`},
		// {`CREATE CHANGEFEED FOR TABLE foo PARTITION bar, baz INTO 'sink'`},
		{`CREATE CHANGEFEED FOR DATABASE foo INTO 'sink'`},
		{`CREATE CHANGEFEED FOR TABLE foo INTO 'sink' WITH bar = 'baz'`},

		// Regression for #15926
		{`SELECT * FROM ((t1 NATURAL JOIN t2 WITH ORDINALITY AS o1)) WITH ORDINALITY AS o2`},
	}

	for _, q := range testData {
		if _, err := Parse(q.sql); err != nil {
			t.Errorf(`could not parse query: "%s" error: "%s"`, q.sql, err.Error())
		} else {
			t.Logf(`parsed query: "%s"`, q.sql)
		}
	}
}
